(()=>{"use strict";if(!(52===new Uint8Array(Uint16Array.from([4660]))[0]))throw new Error("Beson only supports little endian environment!");const t="undefined"!=typeof Buffer,r=Object.freeze({NULL:1,FALSE:2,TRUE:3,STRING:4,INT8:5,INT16:6,INT32:7,INT64:8,INT128:9,INT256:10,INT512:11,UINT8:13,UINT16:14,UINT32:15,UINT64:16,UINT128:17,UINT256:18,UINT512:19,FLOAT32:21,FLOAT64:22,ARRAY:23,SET:24,OBJECT:25,MAP:26,ARRAY_BUFFER:27,INT8_ARRAY:28,UINT8_ARRAY:29,INT16_ARRAY:30,UINT16_ARRAY:31,INT32_ARRAY:32,UINT32_ARRAY:33,FLOAT32_ARRAY:34,FLOAT64_ARRAY:35,DATA_VIEW:36,SPECIAL_BUFFER:37,DATE:38,REGEX:39,END:99,BINARIZABLE:100}),e=Object.freeze({END:0,NULL:16,FALSE:32,TRUE:33,STRING:48,INT8:64,INT16:65,INT32:66,INT64:67,INT128:68,INT256:69,INT512:70,UINT8:80,UINT16:81,UINT32:82,UINT64:83,UINT128:84,UINT256:85,UINT512:86,FLOAT32:96,FLOAT64:97,ARRAY:112,SET:113,OBJECT:128,MAP:129,ARRAY_BUFFER:144,INT8_ARRAY:145,UINT8_ARRAY:146,INT16_ARRAY:147,UINT16_ARRAY:148,INT32_ARRAY:149,UINT32_ARRAY:150,FLOAT32_ARRAY:151,FLOAT64_ARRAY:152,DATA_VIEW:158,SPECIAL_BUFFER:159,DATE:160,REGEX:161}),n=/^0x([0-9a-fA-F]{2})+$/,i=/^0b([01]{8})+$/,a=/^[+-]?\d+$/,u=new Uint8Array([0,202,154,59]),s={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function o(r){if(t&&r instanceof Buffer){let t=Buffer.alloc(r.length);return r.copy(t,0),t.buffer}return ArrayBuffer.isView(r)?r.buffer:r instanceof ArrayBuffer?r:null}function f(...t){if(!t[0]instanceof ArrayBuffer)throw new TypeError("Given inputs must be ArrayBuffers!");Array.isArray(t[0])&&(t=t[0]);let r=0;for(let e of t)r+=e.byteLength;const e=new Uint8Array(r);let n=0;for(let r of t)e.set(new Uint8Array(r),n),n+=r.byteLength;return e.buffer}function l(t){let r=[],e=0;for(;e<t.length;){let n=t.codePointAt(e);0==(4294967168&n)?r.push(n):0==(4294965248&n)?r.push(192|31&n>>6,128|63&n):0==(4294901760&n)?r.push(224|15&n>>12,128|63&n>>6,128|63&n):0==(4292870144&n)&&r.push(240|7&n>>18,128|63&n>>12,128|63&n>>6,128|63&n),e+=n>65535?2:1}return new Uint8Array(r)}function c(t){let r=new Uint8Array(t),e=[],n=0;for(;n<r.length;){let t=255&r[n];0==(128&t)?(e.push(t),n+=1):192==(224&t)?(t=(31&r[n])<<6|63&r[n+1],e.push(t),n+=2):224==(240&t)?(t=(15&r[n])<<12|(63&r[n+1])<<6|63&r[n+2],e.push(t),n+=3):240==(248&t)?(t=(7&r[n])<<18|(63&r[n+1])<<12|(63&r[n+2])<<6|63&r[n+3],e.push(t),n+=4):n+=1}let i="";for(;e.length>0;){const t=e.splice(0,100);i+=String.fromCodePoint(...t)}return i}function h(t){if(null===(t=o(t)))throw new TypeError("Given input must be an ArrayBuffer!");const r=new Uint8Array(t);for(let t=0;t<r.length;t++)r[t]=~r[t]}function A(t){const r=new Uint8Array(o(t));let e=!0;for(let t=0;t<r.length;t++)e=e&&0===r[t];return e}function b(t,r,e,n=0,i=0){for(let a=0;a<e;a++)t[i+a]=r[n+a]}function y(t){if(!(t instanceof ArrayBuffer))throw new TypeError("Given input must be an ArrayBuffer!");return this._ab=t,this._ba=new Uint8Array(this._ab),this}function w(t,r=null){if(!n.test(t))throw new SyntaxError("Given hex string is not a valid hex string!");(t=t.slice(2)).length%2==1&&(t="0"+t);let e=Math.floor(t.length/2);if(arguments.length<=1)r=e;else if(r<0)throw new RangeError("Given buffer size should greater than or equal to 0!");let i=new Uint8Array(r);for(let r=0;r<e;r++){let n=2*(e-r-1);i[r]=s[t[n+1]]|s[t[n]]<<4}return i}function _(t,r=null){if(!i.test(t))throw new SyntaxError("Given hex string is not a valid hex string!");t=t.slice(2);let e=Math.floor(t.length/8);if(arguments.length<=1)r=e;else if(r<0)throw new RangeError("Given buffer size should greater than or equal to 0!");let n=new Uint8Array(r);for(let r=0;r<e;r++){let i=8*(e-r-1);n[r]=Number.parseInt(t.substring(i,i+8),2)}return n}function g(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");if(0===t.byteLength&&0===r.byteLength)return 0;let e,n,i=new Uint8Array(t),a=new Uint8Array(r);for(let t=Math.max(i.length,a.length);t>0;t--)if(e=i[t-1]||0,n=a[t-1]||0,e!==n)return e>n?1:-1;return 0}function U(t,r,e=0){if("number"!=typeof r)throw new TypeError("Shift bits number must be a number");if(null===(t=o(t)))throw new TypeError("Given value must be an ArrayBuffer!");const n=new Uint8Array(t);if(r>0)if(e=e?255:0,r>=8*n.byteLength)n.fill(e);else{const t=r/8|0,i=r%8,a=8-i,u=i?B(i):0,s=n.byteLength-t;for(let r=0;r<s;r++){let s=r+t;if(0===i)n[r]=n[s];else{let t=n[s],o=s>=n.byteLength-1?e:n[s+1];n[r]=t>>>i|(o&u)<<a}}for(let t=s;t<n.byteLength;t++)n[t]=e}}function v(t,r,e=0){if("number"!=typeof r)throw new TypeError("Shift bits must be a number!");if(null===(t=o(t)))throw new TypeError("Given value must be an ArrayBuffer!");const n=new Uint8Array(t);if(r>0)if(e=e?255:0,r>=8*n.byteLength)n.fill(e);else{const t=r/8|0,i=r%8,a=8-i,u=i?B(i)<<a:0;for(let r=n.byteLength-1;r>=t;r--){let s=r-t;if(0===i)n[r]=n[s];else{let t=n[s],o=s<=0?e:n[s-1];n[r]=t<<i|(o&u)>>a}}n.fill(e,0,t)}}function m(t){const r=new Uint8Array(o(t));return 0!=(128&r[r.length-1])}function T(t,r=null){if(!a.test(t))throw new SyntaxError("Given hex string is not a valid hex string!");let e=!1;"-"===t[0]?(e=!0,t=t.substring(1)):"+"===t[0]&&(t=t.substring(1));let n=!0,i=Math.ceil(Math.ceil(t.length*Math.log2(10))/8);if(arguments.length<=1)n=!1,r=i;else if(r<0)throw new RangeError("Given buffer size should greater than or equal to 0!");const s=[];for(;t.length>0;){let r=t.length-9;s.push(Number.parseInt(t.substring(r),10)),t=t.substring(0,r)}s.reverse();const o=new Uint8Array(r),f=new Uint32Array(1);for(let t=0;t<s.length;t++)f[0]=s[t],I(o,u),R(o,f);let l=o;if(!n){let t=r-1;for(;t>0&&0==(255&o[t]);)t--;0!=(128&o[t])&&t++,l=t===r?o:o.slice(0,t+1)}return e&&p(l),l}function I(t,r){const e=new Uint8Array(o(t)),n=new Uint8Array(o(r)),i=new Uint8Array(e.length);let a=0;for(let t=0;t<i.length;t++){for(let r=0;r<=t;r++)a+=e[r]*(n[t-r]||0);i[t]=a,a=a/256|0}e.set(i)}function R(t,r){let e=new Uint8Array(o(t)),n=new Uint8Array(o(r)),i=0;for(let t=0;t<e.length;t++)i+=e[t]+(n[t]||0),e[t]=i,i=i/256|0}function E(t,r){const e=new Uint8Array(o(t)),n=new Uint8Array(o(r)),i=new Uint8Array(n);p(i),R(e,i)}function N(t,r,e=!1,n=null){const i=new Uint8Array(o(t)),a=new Uint8Array(o(r)),u=i,s=new Uint8Array(u.length);if(s.set(a),A(s))throw new TypeError("Dividing zero is not allowed!");let f=0,l=0;e||(f=m(u)?1:0,f&&p(u),l=m(s)?1:0,l&&p(s));const c=new Uint8Array(null!==n?o(n):u.length);c.set(u);const h=u;if(h.fill(0),g(c,s)>=0){let t=c.slice(0),r=s,e=0,n=0,i=8*t.length;for(;i-- >0&&0==(128&t[t.length-1]);)v(t,1),n++;for(t=c,i=8*r.length;i-- >0&&0==(128&r[r.length-1]);)v(r,1),e++;for(U(r,n),i=e-n+1;i-- >0;)g(t,r)>=0&&(E(t,r),h[0]=1|h[0]),i>0&&(v(h,1),U(r,1))}return l^f&&p(h),c}function p(t){if(null===(t=o(t)))throw new TypeError("Given input must be an ArrayBuffer!");const r=new Uint8Array(t);let e=1;for(let t=0;t<r.length;t++)e+=~r[t]>>>0&255,r[t]=e,e=e/256|0}function d(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");if(0===t.byteLength&&0===r.byteLength)return 0;let e,n,i=new Uint8Array(t),a=new Uint8Array(r),u=Math.max(i.length,a.length);for(let t=0;t<u;t++)if(e=i[t]||0,n=a[t]||0,e!==n)return e>n?1:-1;return 0}function B(t){if(t>8)return 255;if(t<0)return 0;let r=0;for(;t-- >0;)r=(r<<1|1)>>>0;return r}const L=new ArrayBuffer(0),S=new Uint8Array(L);class F{constructor(t=0){if(0===arguments.length&&(this._ab=L,this._ba=S),"number"!=typeof t||t<0)throw new TypeError("Given length must be an integer that is equal or greater than 0!");this._ab=new ArrayBuffer(t),this._ba=new Uint8Array(this._ab)}toBytes(t=null){if(null===t)return this._ba.slice(0);if("number"!=typeof t||t<0)throw new Error("Given size argument must be a number greater than zero!");if(this._ba.length===t)return this._ba.slice(0);if(this._ab.length>t)return this._ba.slice(0,t);const r=new Uint8Array(t);return r.set(this._ba),r}toString(t=16){switch(t){case 2:return function(t){let r=new Uint8Array(o(t));const e=r.length;let n="";for(let t=0;t<e;t++){let e=r[t];for(let t=0;t<8;t++)n+=e<<t&128?"1":"0"}return n}(this._ab);case 16:return function(t){let r=new Uint8Array(o(t));const e=r.length;let n="";for(let t=0;t<e;t++){let e=r[t].toString(16);n+=`${1===e.length?"0":""}${e}`}return n}(this._ab);default:throw new RangeError("BinaryData.toString only supports binary & hex representation!")}}compare(t){return this.compareBE(t)}compareLE(t){return g(this._ab,t)}compareBE(t){return d(this._ab,t)}get size(){return this._ab.byteLength}[Symbol.toPrimitive](t){return this.toString(16)}static isBinaryData(t){if(t instanceof F)return!0;if(Object(t)!==t)return!1;let r=!0;return r=r&&t._ab instanceof ArrayBuffer,r=r&&t._ba instanceof Uint8Array,r=r&&"function"==typeof t.toBytes,r}}class O extends F{constructor(){super(),this._ta=this._ba}rshift(t){const r=this.constructor.from(this),e=this.isPositive?0:255;return U(r._ab,t,e),r}lshift(t){const r=this.constructor.from(this);return v(r._ab,t,0),r}not(){const t=this.constructor.from(this);return h(t._ab),t}or(t){const r=this.constructor.from(this),e=this.constructor.from(t);return function(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");const e=new Uint8Array(t),n=new Uint8Array(r);for(let t=0;t<e.length;t++)e[t]=e[t]|(n[t]||0)}(r._ab,e._ab),r}and(t){const r=this.constructor.from(this),e=this.constructor.from(t);return function(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");const e=new Uint8Array(t),n=new Uint8Array(r);for(let t=0;t<e.length;t++)e[t]=e[t]&(n[t]||0)}(r._ab,e._ab),r}xor(t){const r=this.constructor.from(this),e=this.constructor.from(t);return function(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");const e=new Uint8Array(t),n=new Uint8Array(r);for(let t=0;t<e.length;t++)e[t]=e[t]^(n[t]||0)}(r._ab,e._ab),r}add(t){const r=this.constructor.from(this),e=this.constructor.from(t);return R(r._ab,e._ab),r}sub(t){const r=this.constructor.from(this),e=this.constructor.from(t);return E(r._ab,e._ab),r}multipliedBy(t){return this.mul(t)}mul(t){const r=this.constructor.from(this),e=this.constructor.from(t);return I(r._ab,e._ab),r}dividedBy(t){return this.div(t)}div(t){const r=this.constructor.from(this),e=this.constructor.from(t);return N(r._ab,e._ab,!this.isSignedInt),r}modulo(t){return this.mod(t)}mod(t){const r=this.constructor.from(this),e=this.constructor.from(t),n=N(r._ab,e._ab,!this.isSignedInt);return r._ba.set(n),r}compare(t){const r=this.constructor.from(t);return this.compareLE(r._ab)}isZero(){return A(this._ab)}toBytes(t=null){if(null===t)return this._ba.slice(0);if("number"!=typeof t||t<0)throw new Error("Given size argument must be a number greater than zero!");if(this._ba.length===t)return this._ba.slice(0);if(this._ba.length>t)return this._ba.slice(0,t);const r=this.isPositive?0:255,e=new Uint8Array(t);return e.fill(r,this._ba.length,e.length).set(this._ba),e}toString(t=10){switch(t){case 10:return function(t,r=!1){let e=!1;const n=new Uint8Array(o(t).slice(0));!r&&m(n)&&(p(n),e=!0);let i="";const a=new Uint8Array(n.length),u=new Uint8Array(n.length);for(u[0]=100,N(n,u,!0,a);!A(n);){let t=a[0].toString(10);i=(1===t.length?"0"+t:t)+i,N(n,u,!0,a)}return(e?"-":"")+a[0].toString(10)+i}(this._ab,!this.isSignedInt);case 2:return function(t){let r=new Uint8Array(o(t)),e="";for(let t=r.length-1;t>=0;t--){let n=r[t];for(let t=0;t<8;t++)e+=n<<t&128?"1":"0"}return e}(this._ab);case 16:return function(t){let r=new Uint8Array(o(t)),e="";for(let t=r.length-1;t>=0;t--){let n=r[t].toString(16);e+=`${1===n.length?"0":""}${n}`}return e}(this._ab);default:throw new RangeError("BinaryData.toString only supports binary & hex representation!")}}__set_value(t){const r=typeof t;if("number"===r){let r=!1;(t=Math.floor(t))<0&&(r=!0,t=Math.abs(t));for(let r=0;r<this._ba.length;r++)this._ba[r]=t%256,t=Math.floor(t/256);return void(r&&p(this._ab))}if("string"===r){let r;const e=(t=t.trim()).substring(0,2);return r="0x"===e?w(t,this.size):"0b"===e?_(t,this.size):T(t,this.size),void this._ba.set(r)}if(Array.isArray(t)){for(let r=0;r<t.length;r++)if("number"!=typeof t[r])throw new Error("Given array should contains only numbers");return void this._ba.set(t)}const e=o(t);if(e)this._ba.set(new Uint8Array(e));else{if(!F.isBinaryData(t))throw new TypeError("Given value cannot be casted into ArrayBuffer!");this._ba.set(t.toBytes(this.size))}}set value(t){this.__set_value(t)}get isSignedInt(){return!1}get isPositive(){if(!this.isSignedInt)return!0;return 0==(128&this._ba[this._ba.length-1])}[Symbol.toPrimitive](t){const r=this.toString(10);return"string"===t?r:+r}static isBinaryInt(t){return t instanceof O||!!F.isBinaryData(t)&&"boolean"==typeof t.isSignedInt}}const Y=new Uint8Array([255,255,127,127]),M=new Uint8Array([255,255,127,128]),G=new Uint8Array([255,255,255,127]),D=new Uint8Array([0,0,128,127]),x=new Uint8Array([0,0,128,255]);class z extends O{[Symbol.toPrimitive](t){return"string"===t?""+this._ta[0]:this._ta[0]}toString(t=10){return 10===t?this._ta[0].toString():super.toString(t)}}class Z extends z{constructor(t=0){super(),y.call(this,new ArrayBuffer(4)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=F.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Uint32Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new Z(t)}static get ZERO(){return new Z(0)}static get MAX(){return new Z(4294967295)}}class X extends z{constructor(t=0){super(),y.call(this,new ArrayBuffer(4)),this._ta=new Int32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=F.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Int32Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new X(t)}static get ZERO(){return new X(0)}static get MAX(){return new X(2147483647)}static get MIN(){return new X(-2147483648)}}class P extends z{constructor(t=0){super(),y.call(this,new ArrayBuffer(2)),this._ta=new Uint16Array(this._ab),this.__set_value(t)}get isSignedInt(){return!1}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=F.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Uint16Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new P(t)}static get ZERO(){return new P(0)}static get MAX(){return new P(65535)}}class C extends z{constructor(t=0){super(),y.call(this,new ArrayBuffer(2)),this._ta=new Int16Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=F.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Int16Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new C(t)}static get ZERO(){return new C(0)}static get MAX(){return new C(32767)}static get MIN(){return new C(-32768)}}class V extends z{constructor(t=0){super(),y.call(this,new ArrayBuffer(1)),this._ta=this._ba=new Uint8Array(this._ab),this.__set_value(t)}get isSignedInt(){return!1}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=F.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Uint8Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new V(t)}static get ZERO(){return new V(0)}static get MAX(){return new V(255)}}class j extends z{constructor(t=0){super(),y.call(this,new ArrayBuffer(1)),this._ta=new Int8Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=F.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Int8Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new j(t)}static get ZERO(){return new j(0)}static get MAX(){return new j(127)}static get MIN(){return new j(-128)}}class k extends z{constructor(t=0){super(),y.call(this,new ArrayBuffer(4)),this._ta=new Float32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=F.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Float32Array(r.slice(0,4));this._ta[0]=e[0]}static from(t=0){return new k(t)}static get ZERO(){return new k(0)}static get NaN(){return new k(G)}static get MAX_INFINITY(){return new k(D)}static get MIN_INFINITY(){return new k(x)}static get MAX_INT(){return new k(1266679807)}static get MIN_INT(){return new k(3414163455)}static get MAX(){return new k(Y)}static get MIN(){return new k(M)}}class $ extends O{constructor(t=0,r=null){if(super(),null!==r)return y.call(this,new ArrayBuffer(r)),this._ta=this._ba,void this.__set_value(t);if(Array.isArray(t)){for(let r=0;r<t.length;r++)if("number"!=typeof t[r])throw new Error("Given array should contains only numbers");return y.call(this,new ArrayBuffer(t.length)),this._ba.set(t),void(this._ta=this._ba)}let e=o(t);if(null!==e)return y.call(this,new ArrayBuffer(e.byteLength)),this._ba.set(new Uint8Array(e)),void(this._ta=this._ba);if(F.isBinaryData(t))return this._ta=this._ba=t.toBytes(),void(this._ab=this._ba.buffer);let n=typeof t;if("number"===n&&(n="string",t=Math.floor(t).toString(10)),"string"===n){let r;const e=(t=t.trim()).substring(0,2);return r="0x"===e?w(t):"0b"===e?_(t):T(t),this._ta=this._ba=r,void(this._ab=r.buffer)}throw new TypeError("Given value cannot be casted into ArrayBuffer!")}resize(t){if(t===this.size)return;let r=this._ba;y.call(this,new ArrayBuffer(t)),this._ba.set(r),this._ta=this._ba}}class J extends ${static from(t=0){return new J(t)}static ZERO(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t;e++)r.push(0);return new J(r)}static MAX(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t;e++)r.push(255);return new J(r)}}class W extends ${get isSignedInt(){return!0}static from(t=0){return new W(t)}static ZERO(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t;e++)r.push(0);return new W(r)}static MAX(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t-1;e++)r.push(255);return r[t-1]=127,new W(r)}static MIN(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t-1;e++)r.push(0);return r[t-1]=128,new W(r)}}class q extends O{constructor(t=0){super(),y.call(this,new ArrayBuffer(8)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}static from(t=0){return new q(t)}static get ZERO(){return new q}static get MAX(){const t=new q;return t._ta[0]=4294967295,t._ta[1]=4294967295,t}}class H extends O{constructor(t=0){super(),y.call(this,new ArrayBuffer(8)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}static from(t=0){return new H(t)}static get ZERO(){return new H}static get MAX(){const t=new H;return t._ta[1]=2147483647,t._ta[0]=4294967295,t}static get MIN(){const t=new H;return t._ta[1]=2147483648,t._ta[0]=0,t}}class K extends O{constructor(t=0){super(),y.call(this,new ArrayBuffer(16)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}static from(t=0){return new K(t)}static get ZERO(){return new K}static get MAX(){return new K([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255])}}class Q extends O{constructor(t=0){super(),y.call(this,new ArrayBuffer(16)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}static from(t=0){return new Q(t)}static get ZERO(){return new Q}static get MAX(){return new Q([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127])}static get MIN(){return new Q([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128])}}class tt extends O{constructor(t=0){super(),y.call(this,new ArrayBuffer(32)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}static from(t=0){return new tt(t)}static get ZERO(){return new tt}static get MAX(){return new tt([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255])}}class rt extends O{constructor(t=0){super(),y.call(this,new ArrayBuffer(32)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}static from(t=0){return new rt(t)}static get ZERO(){return new rt}static get MAX(){return new rt([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127])}static get MIN(){return new rt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128])}}class et extends O{constructor(t=0){super(),y.call(this,new ArrayBuffer(64)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}static from(t=0){return new et(t)}static get ZERO(){return new et}static get MAX(){return new et([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255])}}class nt extends O{constructor(t=0){super(),y.call(this,new ArrayBuffer(64)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}static from(t=0){return new nt(t)}static get ZERO(){return new nt}static get MAX(){return new nt([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127])}static get MIN(){return new nt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128])}}const it=new Uint8Array([0]).buffer;function at(t,r){st(ut(t,r),t,r)}function ut(n,i){if(null===n)return i(Uint8Array.from([e.NULL]).buffer),r.NULL;const a=typeof n;if("boolean"===a)return i(Uint8Array.from([n?e.TRUE:e.FALSE]).buffer),n?r.TRUE:r.FALSE;if("number"===a)return i(Uint8Array.from([e.FLOAT64]).buffer),r.FLOAT64;if("string"===a)return i(Uint8Array.from([e.STRING]).buffer),r.STRING;if(Array.isArray(n))return i(Uint8Array.from([e.ARRAY]).buffer),r.ARRAY;if(n instanceof j)return i(Uint8Array.from([e.INT8]).buffer),r.INT8;if(n instanceof V)return i(Uint8Array.from([e.UINT8]).buffer),r.UINT8;if(n instanceof C)return i(Uint8Array.from([e.INT16]).buffer),r.INT16;if(n instanceof P)return i(Uint8Array.from([e.UINT16]).buffer),r.UINT16;if(n instanceof X)return i(Uint8Array.from([e.INT32]).buffer),r.INT32;if(n instanceof Z)return i(Uint8Array.from([e.UINT32]).buffer),r.UINT32;if(n instanceof H)return i(Uint8Array.from([e.INT64]).buffer),r.INT64;if(n instanceof q)return i(Uint8Array.from([e.UINT64]).buffer),r.UINT64;if(n instanceof Q)return i(Uint8Array.from([e.INT128]).buffer),r.INT128;if(n instanceof K)return i(Uint8Array.from([e.UINT128]).buffer),r.UINT128;if(n instanceof rt)return i(Uint8Array.from([e.INT256]).buffer),r.INT256;if(n instanceof tt)return i(Uint8Array.from([e.UINT256]).buffer),r.UINT256;if(n instanceof nt)return i(Uint8Array.from([e.INT512]).buffer),r.INT512;if(n instanceof et)return i(Uint8Array.from([e.UINT512]).buffer),r.UINT512;if(n instanceof k)return i(Uint8Array.from([e.FLOAT32]).buffer),r.FLOAT32;if(n instanceof Date)return i(Uint8Array.from([e.DATE]).buffer),r.DATE;if(n instanceof RegExp)return i(Uint8Array.from([e.REGEX]).buffer),r.REGEX;if(n instanceof Map)return i(Uint8Array.from([e.MAP]).buffer),r.MAP;if(n instanceof Set)return i(Uint8Array.from([e.SET]).buffer),r.SET;if(n instanceof ArrayBuffer)return i(Uint8Array.from([e.ARRAY_BUFFER]).buffer),r.ARRAY_BUFFER;if(n instanceof DataView)return i(Uint8Array.from([e.DATA_VIEW]).buffer),r.DATA_VIEW;if(t&&n instanceof Buffer)return i(Uint8Array.from([e.SPECIAL_BUFFER]).buffer),r.SPECIAL_BUFFER;if(n instanceof Uint8Array)return i(Uint8Array.from([e.UINT8_ARRAY]).buffer),r.UINT8_ARRAY;if(n instanceof Int8Array)return i(Uint8Array.from([e.INT8_ARRAY]).buffer),r.INT8_ARRAY;if(n instanceof Uint16Array)return i(Uint8Array.from([e.UINT16_ARRAY]).buffer),r.UINT16_ARRAY;if(n instanceof Int16Array)return i(Uint8Array.from([e.INT16_ARRAY]).buffer),r.INT16_ARRAY;if(n instanceof Uint32Array)return i(Uint8Array.from([e.UINT32_ARRAY]).buffer),r.UINT32_ARRAY;if(n instanceof Int32Array)return i(Uint8Array.from([e.INT32_ARRAY]).buffer),r.INT32_ARRAY;if(n instanceof Float32Array)return i(Uint8Array.from([e.FLOAT32_ARRAY]).buffer),r.FLOAT32_ARRAY;if(n instanceof Float64Array)return i(Uint8Array.from([e.FLOAT64_ARRAY]).buffer),r.FLOAT64_ARRAY;if("object"===a)return"function"==typeof n.toBytes?(i(Uint8Array.from([e.UINT8_ARRAY]).buffer),r.BINARIZABLE):(i(Uint8Array.from([e.OBJECT]).buffer),r.OBJECT);const u=new TypeError("Given data cannot be serialized as beson!");throw u.detail=n,u}function st(t,e,n){if(t!==r.NULL&&t!==r.FALSE&&t!==r.TRUE)if(F.isBinaryData(e))n(e._ab);else if(t!==r.FLOAT64){if(t===r.STRING){const t=l(e);return n(new Uint32Array([t.byteLength]).buffer),void n(t)}if(t!==r.DATE){if(t===r.SPECIAL_BUFFER){const t=new Uint8Array(e.length);t.set(e);return n(new Uint32Array([t.length]).buffer),void n(t.buffer)}if(t===r.BINARIZABLE){const t=e.toBytes();if(!(t instanceof Uint8Array))throw new TypeError("Beson binary interface `toBytes` must return Uint8Array instance!");return n(new Uint32Array([t.length]).buffer),void n(t.buffer)}if(e instanceof ArrayBuffer){return n(new Uint32Array([e.byteLength]).buffer),void n(e)}if(ArrayBuffer.isView(e)){const t=e.buffer;return n(new Uint32Array([t.byteLength]).buffer),void n(t)}if(t===r.REGEX){const t=l(e.source);if(t.byteLength>65535)throw new RangeError("Beson can only accept regex with source string not longer than 65535 bytes!");const r=l(e.flags);if(r.byteLength>255)throw new RangeError("Beson can only accept regex with flag string not longer than 255 bytes!");return n(Uint16Array.from([t.byteLength]).buffer),n(t),n(Uint8Array.from([r.byteLength]).buffer),void n(r)}return t===r.ARRAY||t===r.SET?function(t,r){for(let e of t){void 0===e&&(e=null);st(ut(e,r),e,r)}r(it)}(e,n):t===r.OBJECT?function(t,r){for(let e in t){const n=t[e];if(void 0===n)continue;const i=ut(n,r);ot(""+e,r),st(i,n,r)}r(it)}(e,n):t===r.MAP?function(t,r){for(let[e,n]of t){if(void 0===n)continue;Object(e)===e&&console.error("You're serializing a Map that contains object key!");st(ut(e,r),e,r);st(ut(n,r),n,r)}r(it)}(e,n):void 0}n(new Float64Array([e.getTime()]).buffer)}else{n(new Float64Array([e]).buffer)}}function ot(t,r){const e=l(t);if(e.byteLength>65535)throw new RangeError("Given key cannot be larger than 65565 bytes!");r(Uint16Array.from([e.byteLength]).buffer),r(e)}const ft=new WeakMap;class lt{constructor(){const t=[];ft.set(this,{parts:t,data_cb:r=>{t.push(r)}})}write(t){return at(t,ft.get(this).data_cb),this}get size(){const{parts:t}=ft.get(this);let r=0;for(const e of t)r+=e.byteLength;return r}get buffer(){return f(ft.get(this).parts)}static init(){return new lt}}function ct(r,e=0){if(t&&r instanceof Buffer){let t=Buffer.alloc(r.length);r.copy(t,0),r=t.buffer}return function(t,r){const e=ht(t,r);if(!e)return e;return At(e.value,t,e.anchor)}(r,e)}function ht(t,n){if(t.length<n+1)return!1;const i=t[n];let a=null;for(const t in e){i===e[t]&&(a=r[t])}return a?{anchor:n+1,value:a}:void 0}function At(e,n,i){if(e===r.NULL)return{anchor:i,value:null};if(e===r.TRUE)return{anchor:i,value:!0};if(e===r.FALSE)return{anchor:i,value:!1};if(e===r.INT8)return function(t,r){if(t.length<r+1)return!1;const e=j.ZERO;return b(e._ba,t,1,r),{anchor:r+1,value:e}}(n,i);if(e===r.INT16)return function(t,r){if(t.length<r+2)return!1;const e=C.ZERO;return b(e._ba,t,2,r),{anchor:r+2,value:e}}(n,i);if(e===r.INT32)return function(t,r){if(t.length<r+4)return!1;const e=X.ZERO;return b(e._ba,t,4,r),{anchor:r+4,value:e}}(n,i);if(e===r.INT64)return function(t,r){if(t.length<r+8)return!1;const e=H.ZERO;return b(e._ba,t,8,r),{anchor:r+8,value:e}}(n,i);if(e===r.INT128)return function(t,r){if(t.length<r+16)return!1;const e=Q.ZERO;return b(e._ba,t,16,r),{anchor:r+16,value:e}}(n,i);if(e===r.INT256)return function(t,r){if(t.length<r+32)return!1;const e=rt.ZERO;return b(e._ba,t,32,r),{anchor:r+32,value:e}}(n,i);if(e===r.INT512)return function(t,r){if(t.length<r+64)return!1;const e=nt.ZERO;return b(e._ba,t,64,r),{anchor:r+64,value:e}}(n,i);if(e===r.UINT8)return function(t,r){if(t.length<r+1)return!1;const e=V.ZERO;return b(e._ba,t,1,r),{anchor:r+1,value:e}}(n,i);if(e===r.UINT16)return function(t,r){if(t.length<r+2)return!1;const e=P.ZERO;return b(e._ba,t,2,r),{anchor:r+2,value:e}}(n,i);if(e===r.UINT32)return function(t,r){if(t.length<r+4)return!1;const e=Z.ZERO;return b(e._ba,t,4,r),{anchor:r+4,value:e}}(n,i);if(e===r.UINT64)return function(t,r){if(t.length<r+8)return!1;const e=q.ZERO;return b(e._ba,t,8,r),{anchor:r+8,value:e}}(n,i);if(e===r.UINT128)return function(t,r){if(t.length<r+16)return!1;const e=K.ZERO;return b(e._ba,t,16,r),{anchor:r+16,value:e}}(n,i);if(e===r.UINT256)return function(t,r){if(t.length<r+32)return!1;const e=tt.ZERO;return b(e._ba,t,32,r),{anchor:r+32,value:e}}(n,i);if(e===r.UINT512)return function(t,r){if(t.length<r+64)return!1;const e=et.ZERO;return b(e._ba,t,64,r),{anchor:r+64,value:e}}(n,i);if(e===r.FLOAT32)return function(t,r){if(t.length<r+4)return!1;const e=k.ZERO;return b(e._ba,t,4,r),{anchor:r+4,value:e}}(n,i);if(e===r.FLOAT64)return function(t,r){if(t.length<r+8)return!1;const e=new Float64Array(t.slice(r,r+8).buffer);return{anchor:r+8,value:e[0]}}(n,i);if(e===r.STRING)return function(t,r){let e=4;if(t.length<r+e)return!1;const n=new Uint32Array(t.slice(r,r+e).buffer);if(r+=e,e=n[0],t.length<r+e)return!1;const i=new Uint8Array(t.slice(r,r+e).buffer);return{anchor:r+=e,value:c(i.buffer)}}(n,i);if(e===r.DATE)return function(t,r){if(t.length<r+8)return!1;const e=new Float64Array(t.slice(r,r+8).buffer);return{anchor:r+8,value:new Date(e[0])}}(n,i);if(e===r.ARRAY_BUFFER)return yt(n,i);if(e===r.DATA_VIEW){const t=yt(n,i);return t?(t.value=new DataView(t.value),t):t}if(e===r.UINT8_ARRAY){const t=yt(n,i);return t?(t.value=new Uint8Array(t.value),t):t}if(e===r.INT8_ARRAY){const t=yt(n,i);return t?(t.value=new Int8Array(t.value),t):t}if(e===r.UINT16_ARRAY){const t=yt(n,i);return t?(t.value=new Uint16Array(t.value),t):t}if(e===r.INT16_ARRAY){const t=yt(n,i);return t?(t.value=new Int16Array(t.value),t):t}if(e===r.UINT32_ARRAY){const t=yt(n,i);return t?(t.value=new Uint32Array(t.value),t):t}if(e===r.INT32_ARRAY){const t=yt(n,i);return t?(t.value=new Int32Array(t.value),t):t}if(e===r.FLOAT32_ARRAY){const t=yt(n,i);return t?(t.value=new Float32Array(t.value),t):t}if(e===r.FLOAT64_ARRAY){const t=yt(n,i);return t?(t.value=new Float64Array(t.value),t):t}if(e===r.SPECIAL_BUFFER){const r=yt(n,i);return r?(r.value=t?Buffer.from(r.value):new Uint8Array(r.value),r):r}return e===r.ARRAY?function(t,e){const n=[];for(;e<t.byteLength;){let i=ht(t,e);if(!i)return i;e=i.anchor;const a=i.value;if(a===r.END)break;if(i=At(a,t,e),!i)return i;e=i.anchor,n.push(i.value)}return{anchor:e,value:n}}(n,i):e===r.OBJECT?function(t,e){const n={};for(;e<t.byteLength;){let i=ht(t,e);if(!i)return i;e=i.anchor;const a=i.value;if(a===r.END)break;if(i=bt(t,e),!i)return i;e=i.anchor;const u=i.value;if(i=At(a,t,e),!i)return i;e=i.anchor,n[u]=i.value}return{anchor:e,value:n}}(n,i):e===r.SET?function(t,e){const n=new Set;for(;e<t.byteLength;){let i=ht(t,e);if(!i)return i;e=i.anchor;const a=i.value;if(a===r.END)break;if(i=At(a,t,e),!i)return i;e=i.anchor,n.add(i.value)}return{anchor:e,value:n}}(n,i):e===r.MAP?function(t,e){const n=new Map;for(;e<t.byteLength;){let i=ht(t,e);if(!i)return i;e=i.anchor;const a=i.value;if(a===r.END)break;if(i=At(a,t,e),!i)return i;e=i.anchor;const u=i.value;if(i=ht(t,e),!i)return i;e=i.anchor;const s=i.value;if(s===r.END)break;if(i=At(s,t,e),!i)return i;e=i.anchor,n.set(u,i.value)}return{anchor:e,value:n}}(n,i):e===r.REGEX?function(t,r){let e=2;if(t.length<r+e)return!1;const n=new Uint16Array(t.slice(r,r+e).buffer);if(r+=e,e=n[0],t.length<r+e)return!1;const i=t.slice(r,r+e).buffer;if(r+=e,e=1,t.length<r+e)return!1;const a=t[r];if(r+=e,e=a,t.length<r+e)return!1;const u=t.slice(r,r+e).buffer;return{anchor:r+=e,value:new RegExp(c(i),c(u))}}(n,i):void 0}function bt(t,r){let e=2;if(t.length<r+e)return!1;const n=new Uint16Array(t.slice(r,r+e).buffer);if(r+=e,e=n[0],t.length<r+e)return!1;const i=new Uint8Array(t.slice(r,r+e).buffer);return{anchor:r+=e,value:c(i.buffer)}}function yt(t,r){let e=4;if(t.length<r+e)return!1;const n=new Uint32Array(t.slice(r,r+e).buffer);if(r+=e,e=n[0],t.length<r+e)return!1;const i=t.slice(r,r+e).buffer;return{anchor:r+=e,value:i}}const wt=new Uint8Array(new ArrayBuffer(0));class _t{constructor(){ft.set(this,{buffer:wt}),this.throw_if_error=!1}read(){const t=ft.get(this),r=ct(t.buffer);if(void 0!==r){if(!1!==r){const{anchor:e,value:n}=r;return t.buffer=t.buffer.slice(e),n}}else if(this.throw_if_error)throw new TypeError("Data stored in Deserializer is not encoded in valid beson format")}append(t){if(ArrayBuffer.isView(t)&&(t=t.buffer),!(t instanceof ArrayBuffer))throw new TypeError("Given buffer is not an ArrayBuffer!");const r=ft.get(this);return r.buffer=new Uint8Array(f(r.buffer.buffer,t)),this}get size(){return ft.get(this).buffer.length}get buffer(){return ft.get(this).buffer.slice(0).buffer}static init(t=null){const r=new _t;return null===t&&(t=wt),r.append(t),r}}let gt;"undefined"!=typeof module&&module.exports?gt=module.exports:"undefined"!=typeof window&&(gt=window.beson=window.beson||{});const Ut={};Object.defineProperties(Ut,{DeserializeBuffer:{value:ct,enumerable:!0},Deserializer:{value:_t,enumerable:!0},Serializer:{value:lt,enumerable:!0},UTF8Encode:{value:l,enumerable:!0},UTF8Decode:{value:c,enumerable:!0}}),Object.defineProperties(gt,{Int8:{value:j,enumerable:!0},Int16:{value:C,enumerable:!0},Int32:{value:X,enumerable:!0},Int64:{value:H,enumerable:!0},Int128:{value:Q,enumerable:!0},Int256:{value:rt,enumerable:!0},Int512:{value:nt,enumerable:!0},IntVar:{value:W,enumerable:!0},UInt8:{value:V,enumerable:!0},UInt16:{value:P,enumerable:!0},UInt32:{value:Z,enumerable:!0},UInt64:{value:q,enumerable:!0},UInt128:{value:K,enumerable:!0},UInt256:{value:tt,enumerable:!0},UInt512:{value:et,enumerable:!0},UIntVar:{value:J,enumerable:!0},Float32:{value:k,enumerable:!0},Deserialize:{value:function(t,r=!1){const e=ct(t=new Uint8Array(t),0);if(e)return e.value;if(r)throw new TypeError("Input data is not encoded in beson format!")},enumerable:!0},Serialize:{value:function(t){const r=[];return at(t,t=>{r.push(t)}),f(r)},enumerable:!0},Misc:{value:Ut,enumerable:!0}})})();
