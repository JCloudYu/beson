(()=>{"use strict";if(!(52===new Uint8Array(Uint16Array.from([4660]))[0]))throw new Error("Beson only supports little endian environment!");const t="undefined"!=typeof Buffer,r=Object.freeze({NULL:1,FALSE:2,TRUE:3,STRING:4,INT8:5,INT16:6,INT32:7,INT64:8,INT128:9,INT256:10,INT512:11,UINT8:13,UINT16:14,UINT32:15,UINT64:16,UINT128:17,UINT256:18,UINT512:19,FLOAT32:21,FLOAT64:22,ARRAY:23,SET:24,OBJECT:25,MAP:26,ARRAY_BUFFER:27,INT8_ARRAY:28,UINT8_ARRAY:29,INT16_ARRAY:30,UINT16_ARRAY:31,INT32_ARRAY:32,UINT32_ARRAY:33,FLOAT32_ARRAY:34,FLOAT64_ARRAY:35,DATA_VIEW:36,SPECIAL_BUFFER:37,DATE:38,REGEX:39,END:99,BINARIZABLE:100}),e=Object.freeze({END:0,NULL:16,FALSE:32,TRUE:33,STRING:48,INT8:64,INT16:65,INT32:66,INT64:67,INT128:68,INT256:69,INT512:70,UINT8:80,UINT16:81,UINT32:82,UINT64:83,UINT128:84,UINT256:85,UINT512:86,FLOAT32:96,FLOAT64:97,ARRAY:112,SET:113,OBJECT:128,MAP:129,ARRAY_BUFFER:144,INT8_ARRAY:145,UINT8_ARRAY:146,INT16_ARRAY:147,UINT16_ARRAY:148,INT32_ARRAY:149,UINT32_ARRAY:150,FLOAT32_ARRAY:151,FLOAT64_ARRAY:152,DATA_VIEW:158,SPECIAL_BUFFER:159,DATE:160,REGEX:161}),n=/^0x([0-9a-fA-F]{2})+$/,i=/^0b([01]{8})+$/,a=/^[+-]?\d+$/,s=new Uint8Array([0,202,154,59]),u={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function o(r){if(t&&r instanceof Buffer){let t=Buffer.alloc(r.length);return r.copy(t,0),t.buffer}return ArrayBuffer.isView(r)?r.buffer:r instanceof ArrayBuffer?r:null}function f(...t){if(!t[0]instanceof ArrayBuffer)throw new TypeError("Given inputs must be ArrayBuffers!");Array.isArray(t[0])&&(t=t[0]);let r=0;for(let e of t)r+=e.byteLength;const e=new Uint8Array(r);let n=0;for(let r of t)e.set(new Uint8Array(r),n),n+=r.byteLength;return e.buffer}function l(t){let r=[],e=0;for(;e<t.length;){let n=t.codePointAt(e);0==(4294967168&n)?r.push(n):0==(4294965248&n)?r.push(192|31&n>>6,128|63&n):0==(4294901760&n)?r.push(224|15&n>>12,128|63&n>>6,128|63&n):0==(4292870144&n)&&r.push(240|7&n>>18,128|63&n>>12,128|63&n>>6,128|63&n),e+=n>65535?2:1}return new Uint8Array(r)}function c(t){let r=new Uint8Array(t),e=[],n=0;for(;n<r.length;){let t=255&r[n];0==(128&t)?(e.push(t),n+=1):192==(224&t)?(t=(31&r[n])<<6|63&r[n+1],e.push(t),n+=2):224==(240&t)?(t=(15&r[n])<<12|(63&r[n+1])<<6|63&r[n+2],e.push(t),n+=3):240==(248&t)?(t=(7&r[n])<<18|(63&r[n+1])<<12|(63&r[n+2])<<6|63&r[n+3],e.push(t),n+=4):n+=1}let i="";for(;e.length>0;){const t=e.splice(0,100);i+=String.fromCodePoint(...t)}return i}function h(t){const r=new Uint8Array(o(t));let e=!0;for(let t=0;t<r.length;t++)e=e&&0===r[t];return e}function A(t,r,e,n=0,i=0){for(let a=0;a<e;a++)t[i+a]=r[n+a]}function b(t){if(!(t instanceof ArrayBuffer))throw new TypeError("Given input must be an ArrayBuffer!");return this._ab=t,this._ba=new Uint8Array(this._ab),this}function y(t,r=null){if(!n.test(t))throw new SyntaxError("Given hex string is not a valid hex string!");(t=t.slice(2)).length%2==1&&(t="0"+t);let e=Math.floor(t.length/2);if(arguments.length<=1)r=e;else if(r<0)throw new RangeError("Given buffer size should greater than or equal to 0!");let i=new Uint8Array(r);for(let r=0;r<e;r++){let n=2*(e-r-1);i[r]=u[t[n+1]]|u[t[n]]<<4}return i}function w(t,r=null){if(!i.test(t))throw new SyntaxError("Given hex string is not a valid hex string!");t=t.slice(2);let e=Math.floor(t.length/8);if(arguments.length<=1)r=e;else if(r<0)throw new RangeError("Given buffer size should greater than or equal to 0!");let n=new Uint8Array(r);for(let r=0;r<e;r++){let i=8*(e-r-1);n[r]=Number.parseInt(t.substring(i,i+8),2)}return n}function _(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");if(0===t.byteLength&&0===r.byteLength)return 0;let e,n,i=new Uint8Array(t),a=new Uint8Array(r);for(let t=Math.max(i.length,a.length);t>0;t--)if(e=i[t-1]||0,n=a[t-1]||0,e!==n)return e>n?1:-1;return 0}function g(t,r,e=0){if("number"!=typeof r)throw new TypeError("Shift bits number must be a number");if(null===(t=o(t)))throw new TypeError("Given value must be an ArrayBuffer!");const n=new Uint8Array(t);if(r>0)if(e=e?255:0,r>=8*n.byteLength)n.fill(e);else{const t=r/8|0,i=r%8,a=8-i,s=i?N(i):0,u=n.byteLength-t;for(let r=0;r<u;r++){let u=r+t;if(0===i)n[r]=n[u];else{let t=n[u],o=u>=n.byteLength-1?e:n[u+1];n[r]=t>>>i|(o&s)<<a}}for(let t=u;t<n.byteLength;t++)n[t]=e}}function U(t,r,e=0){if("number"!=typeof r)throw new TypeError("Shift bits must be a number!");if(null===(t=o(t)))throw new TypeError("Given value must be an ArrayBuffer!");const n=new Uint8Array(t);if(r>0)if(e=e?255:0,r>=8*n.byteLength)n.fill(e);else{const t=r/8|0,i=r%8,a=8-i,s=i?N(i)<<a:0;for(let r=n.byteLength-1;r>=t;r--){let u=r-t;if(0===i)n[r]=n[u];else{let t=n[u],o=u<=0?e:n[u-1];n[r]=t<<i|(o&s)>>a}}n.fill(e,0,t)}}function v(t){const r=new Uint8Array(o(t));return 0!=(128&r[r.length-1])}function m(t,r=null){if(!a.test(t))throw new SyntaxError("Given hex string is not a valid hex string!");let e=!1;"-"===t[0]?(e=!0,t=t.substring(1)):"+"===t[0]&&(t=t.substring(1));let n=!0,i=Math.ceil(Math.ceil(t.length*Math.log2(10))/8);if(arguments.length<=1)n=!1,r=i;else if(r<0)throw new RangeError("Given buffer size should greater than or equal to 0!");const u=[];for(;t.length>0;){let r=t.length-9;u.push(Number.parseInt(t.substring(r),10)),t=t.substring(0,r)}u.reverse();const o=new Uint8Array(r),f=new Uint32Array(1);for(let t=0;t<u.length;t++)f[0]=u[t],I(o,s),T(o,f);let l=o;if(!n){let t=r-1;for(;t>0&&0==(255&o[t]);)t--;0!=(128&o[t])&&t++,l=t===r?o:o.slice(0,t+1)}return e&&p(l),l}function I(t,r){const e=new Uint8Array(o(t)),n=new Uint8Array(o(r)),i=new Uint8Array(e.length);let a=0;for(let t=0;t<i.length;t++){for(let r=0;r<=t;r++)a+=e[r]*(n[t-r]||0);i[t]=a,a=a/256|0}e.set(i)}function T(t,r){let e=new Uint8Array(o(t)),n=new Uint8Array(o(r)),i=0;for(let t=0;t<e.length;t++)i+=e[t]+(n[t]||0),e[t]=i,i=i/256|0}function R(t,r){const e=new Uint8Array(o(t)),n=new Uint8Array(o(r)),i=new Uint8Array(n);p(i),T(e,i)}function E(t,r,e=!1,n=null){const i=new Uint8Array(o(t)),a=new Uint8Array(o(r)),s=i,u=new Uint8Array(s.length);if(u.set(a),h(u))throw new TypeError("Dividing zero is not allowed!");let f=0,l=0;e||(f=v(s)?1:0,f&&p(s),l=v(u)?1:0,l&&p(u));const c=new Uint8Array(null!==n?o(n):s.length);c.set(s);const A=s;if(A.fill(0),_(c,u)>=0){let t=c.slice(0),r=u,e=0,n=0,i=8*t.length;for(;i-- >0&&0==(128&t[t.length-1]);)U(t,1),n++;for(t=c,i=8*r.length;i-- >0&&0==(128&r[r.length-1]);)U(r,1),e++;for(g(r,n),i=e-n+1;i-- >0;)_(t,r)>=0&&(R(t,r),A[0]=1|A[0]),i>0&&(U(A,1),g(r,1))}return l^f&&p(A),c}function p(t){if(null===(t=o(t)))throw new TypeError("Given input must be an ArrayBuffer!");const r=new Uint8Array(t);let e=1;for(let t=0;t<r.length;t++)e+=~r[t]>>>0&255,r[t]=e,e=e/256|0}function N(t){if(t>8)return 255;if(t<0)return 0;let r=0;for(;t-- >0;)r=(r<<1|1)>>>0;return r}const d=new ArrayBuffer(0),B=new Uint8Array(d);class L{constructor(t=0){if(0===arguments.length&&(this._ab=d,this._ba=B),"number"!=typeof t||t<0)throw new TypeError("Given length must be an integer that is equal or greater than 0!");this._ab=new ArrayBuffer(t),this._ba=new Uint8Array(this._ab)}toBytes(t=null){if("number"!=typeof(t=null===t?this._ba.length:t)||t<0)throw new Error("Given size argument must be a number greater than zero!");const r=new Uint8Array(t);return r.set(this._ba),r}toString(t=16){switch(t){case 2:return function(t){let r=new Uint8Array(o(t));const e=r.length;let n="";for(let t=0;t<e;t++){let e=r[t];for(let t=0;t<8;t++)n+=e<<t&128?"1":"0"}return n}(this._ab);case 16:return function(t){let r=new Uint8Array(o(t));const e=r.length;let n="";for(let t=0;t<e;t++){let e=r[t].toString(16);n+=`${1===e.length?"0":""}${e}`}return n}(this._ab);default:throw new RangeError("BinaryData.toString only supports binary & hex representation!")}}compare(t){return this.compareBE(t)}compareLE(t){return _(this._ab,t)}compareBE(t){return function(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");if(0===t.byteLength&&0===r.byteLength)return 0;let e,n,i=new Uint8Array(t),a=new Uint8Array(r),s=Math.max(i.length,a.length);for(let t=0;t<s;t++)if(e=i[t]||0,n=a[t]||0,e!==n)return e>n?1:-1;return 0}(this._ab,t)}get size(){return this._ab.byteLength}[Symbol.toPrimitive](t){return this.toString(16)}static isBinaryData(t){if(t instanceof L)return!0;if(Object(t)!==t)return!1;let r=!0;return r=r&&t._ab instanceof ArrayBuffer,r=r&&t._ba instanceof Uint8Array,r=r&&"function"==typeof t.toBytes,r}}class S extends L{constructor(){super(),this._ta=this._ba}rshift(t){const r=this.constructor.from(this),e=this.isPositive?0:255;return g(r._ab,t,e),r}lshift(t){const r=this.constructor.from(this);return U(r._ab,t,0),r}not(){const t=this.constructor.from(this);return function(t){if(null===(t=o(t)))throw new TypeError("Given input must be an ArrayBuffer!");const r=new Uint8Array(t);for(let t=0;t<r.length;t++)r[t]=~r[t]}(t._ab),t}or(t){const r=this.constructor.from(this),e=this.constructor.from(t);return function(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");const e=new Uint8Array(t),n=new Uint8Array(r);for(let t=0;t<e.length;t++)e[t]=e[t]|(n[t]||0)}(r._ab,e._ab),r}and(t){const r=this.constructor.from(this),e=this.constructor.from(t);return function(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");const e=new Uint8Array(t),n=new Uint8Array(r);for(let t=0;t<e.length;t++)e[t]=e[t]&(n[t]||0)}(r._ab,e._ab),r}xor(t){const r=this.constructor.from(this),e=this.constructor.from(t);return function(t,r){if(t=o(t),r=o(r),null===t||null===r)throw new TypeError("Given inputs must be ArrayBuffers!");const e=new Uint8Array(t),n=new Uint8Array(r);for(let t=0;t<e.length;t++)e[t]=e[t]^(n[t]||0)}(r._ab,e._ab),r}add(t){const r=this.constructor.from(this),e=this.constructor.from(t);return T(r._ab,e._ab),r}sub(t){const r=this.constructor.from(this),e=this.constructor.from(t);return R(r._ab,e._ab),r}multipliedBy(t){return this.mul(t)}mul(t){const r=this.constructor.from(this),e=this.constructor.from(t);return I(r._ab,e._ab),r}dividedBy(t){return this.div(t)}div(t){const r=this.constructor.from(this),e=this.constructor.from(t);return E(r._ab,e._ab,!this.isSignedInt),r}modulo(t){return this.mod(t)}mod(t){const r=this.constructor.from(this),e=this.constructor.from(t),n=E(r._ab,e._ab,!this.isSignedInt);return r._ba.set(n),r}compare(t){const r=this.constructor.from(t);return this.compareLE(r._ab)}isZero(){return h(this._ab)}toBytes(t=null){if(null===t)return this._ba.slice(0);if("number"!=typeof t||t<0)throw new Error("Given size argument must be a number greater than zero!");if(this._ba.length===t)return this._ba.slice(0);if(this._ba.length>t)return this._ba.slice(0,t);const r=this.isPositive?0:255,e=new Uint8Array(t);return e.fill(r,this._ba.length,e.length).set(this._ba),e}toString(t=10){switch(t){case 10:return function(t,r=!1){let e=!1;const n=new Uint8Array(o(t).slice(0));!r&&v(n)&&(p(n),e=!0);let i="";const a=new Uint8Array(n.length),s=new Uint8Array(n.length);for(s[0]=100,E(n,s,!0,a);!h(n);){let t=a[0].toString(10);i=(1===t.length?`0${t}`:t)+i,E(n,s,!0,a)}return(e?"-":"")+a[0].toString(10)+i}(this._ab,!this.isSignedInt);case 2:return function(t){let r=new Uint8Array(o(t)),e="";for(let t=r.length-1;t>=0;t--){let n=r[t];for(let t=0;t<8;t++)e+=n<<t&128?"1":"0"}return e}(this._ab);case 16:return function(t){let r=new Uint8Array(o(t)),e="";for(let t=r.length-1;t>=0;t--){let n=r[t].toString(16);e+=`${1===n.length?"0":""}${n}`}return e}(this._ab);default:throw new RangeError("BinaryData.toString only supports binary & hex representation!")}}__set_value(t){const r=typeof t;if("number"===r){let r=!1;(t=Math.floor(t))<0&&(r=!0,t=Math.abs(t));for(let r=0;r<this._ba.length;r++)this._ba[r]=t%256,t=Math.floor(t/256);return void(r&&p(this._ab))}if("string"===r){let r;const e=(t=t.trim()).substring(0,2);return r="0x"===e?y(t,this.size):"0b"===e?w(t,this.size):m(t,this.size),void this._ba.set(r)}if(Array.isArray(t)){for(let r=0;r<t.length;r++)if("number"!=typeof t[r])throw new Error("Given array should contains only numbers");return void this._ba.set(t)}const e=o(t);if(e)this._ba.set(new Uint8Array(e));else{if(!L.isBinaryData(t))throw new TypeError("Given value cannot be casted into ArrayBuffer!");this._ba.set(t.toBytes(this.size))}}set value(t){this.__set_value(t)}get isSignedInt(){return!1}get isPositive(){if(!this.isSignedInt)return!0;return 0==(128&this._ba[this._ba.length-1])}[Symbol.toPrimitive](t){const r=this.toString(10);return"string"===t?r:+r}static isBinaryInt(t){return t instanceof S||!!L.isBinaryData(t)&&"boolean"==typeof t.isSignedInt}}const F=new Uint8Array([255,255,127,127]),O=new Uint8Array([255,255,127,128]),Y=new Uint8Array([255,255,255,127]),G=new Uint8Array([0,0,128,127]),M=new Uint8Array([0,0,128,255]);class D extends S{[Symbol.toPrimitive](t){return"string"===t?`${this._ta[0]}`:this._ta[0]}toString(t=10){return 10===t?this._ta[0].toString():super.toString(t)}}class x extends D{constructor(t=0){super(),b.call(this,new ArrayBuffer(4)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=L.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Uint32Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new x(t)}static get ZERO(){return new x(0)}static get MAX(){return new x(4294967295)}}class z extends D{constructor(t=0){super(),b.call(this,new ArrayBuffer(4)),this._ta=new Int32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=L.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Int32Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new z(t)}static get ZERO(){return new z(0)}static get MAX(){return new z(2147483647)}static get MIN(){return new z(-2147483648)}}class Z extends D{constructor(t=0){super(),b.call(this,new ArrayBuffer(2)),this._ta=new Uint16Array(this._ab),this.__set_value(t)}get isSignedInt(){return!1}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=L.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Uint16Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new Z(t)}static get ZERO(){return new Z(0)}static get MAX(){return new Z(65535)}}class X extends D{constructor(t=0){super(),b.call(this,new ArrayBuffer(2)),this._ta=new Int16Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=L.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Int16Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new X(t)}static get ZERO(){return new X(0)}static get MAX(){return new X(32767)}static get MIN(){return new X(-32768)}}class P extends D{constructor(t=0){super(),b.call(this,new ArrayBuffer(1)),this._ta=this._ba=new Uint8Array(this._ab),this.__set_value(t)}get isSignedInt(){return!1}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=L.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Uint8Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new P(t)}static get ZERO(){return new P(0)}static get MAX(){return new P(255)}}class $ extends D{constructor(t=0){super(),b.call(this,new ArrayBuffer(1)),this._ta=new Int8Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=L.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Int8Array(r.slice(0,1));this._ta[0]=e[0]}static from(t=0){return new $(t)}static get ZERO(){return new $(0)}static get MAX(){return new $(127)}static get MIN(){return new $(-128)}}class C extends D{constructor(t=0){super(),b.call(this,new ArrayBuffer(4)),this._ta=new Float32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}__set_value(t){if("number"==typeof t)return void(this._ta[0]=t);let r=null;if(r=L.isBinaryData(t)?t._ab:o(t),null===r)throw new TypeError("Given value cannot be casted into ArrayBuffer!");const e=new Float32Array(r.slice(0,4));this._ta[0]=e[0]}static from(t=0){return new C(t)}static get ZERO(){return new C(0)}static get NaN(){return new C(Y)}static get MAX_INFINITY(){return new C(G)}static get MIN_INFINITY(){return new C(M)}static get MAX_INT(){return new C(1266679807)}static get MIN_INT(){return new C(3414163455)}static get MAX(){return new C(F)}static get MIN(){return new C(O)}}class V extends S{constructor(t=0,r=null){if(super(),null!==r)return b.call(this,new ArrayBuffer(r)),this._ta=this._ba,void this.__set_value(t);if(Array.isArray(t)){for(let r=0;r<t.length;r++)if("number"!=typeof t[r])throw new Error("Given array should contains only numbers");return b.call(this,new ArrayBuffer(t.length)),this._ba.set(t),void(this._ta=this._ba)}let e=o(t);if(null!==e)return b.call(this,new ArrayBuffer(e.byteLength)),this._ba.set(new Uint8Array(e)),void(this._ta=this._ba);if(L.isBinaryData(t))return this._ta=this._ba=t.toBytes(),void(this._ab=this._ba.buffer);let n=typeof t;if("number"===n&&(n="string",t=Math.floor(t).toString(10)),"string"===n){let r;const e=(t=t.trim()).substring(0,2);return r="0x"===e?y(t):"0b"===e?w(t):m(t),this._ta=this._ba=r,void(this._ab=r.buffer)}throw new TypeError("Given value cannot be casted into ArrayBuffer!")}resize(t){if(t===this.size)return;let r=this._ba;b.call(this,new ArrayBuffer(t)),this._ba.set(r),this._ta=this._ba}}class j extends V{static from(t=0){return new j(t)}static ZERO(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t;e++)r.push(0);return new j(r)}static MAX(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t;e++)r.push(255);return new j(r)}}class k extends V{get isSignedInt(){return!0}static from(t=0){return new k(t)}static ZERO(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t;e++)r.push(0);return new k(r)}static MAX(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t-1;e++)r.push(255);return r[t-1]=127,new k(r)}static MIN(t){if("number"!=typeof t&&t<=0)throw new Error("Given size must be a number greater than zero!");let r=[];for(let e=0;e<t-1;e++)r.push(0);return r[t-1]=128,new k(r)}}class J extends S{constructor(t=0){super(),b.call(this,new ArrayBuffer(8)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}static from(t=0){return new J(t)}static get ZERO(){return new J}static get MAX(){const t=new J;return t._ta[0]=4294967295,t._ta[1]=4294967295,t}}class W extends S{constructor(t=0){super(),b.call(this,new ArrayBuffer(8)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}static from(t=0){return new W(t)}static get ZERO(){return new W}static get MAX(){const t=new W;return t._ta[1]=2147483647,t._ta[0]=4294967295,t}static get MIN(){const t=new W;return t._ta[1]=2147483648,t._ta[0]=0,t}}class q extends S{constructor(t=0){super(),b.call(this,new ArrayBuffer(16)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}static from(t=0){return new q(t)}static get ZERO(){return new q}static get MAX(){return new q([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255])}}class H extends S{constructor(t=0){super(),b.call(this,new ArrayBuffer(16)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}static from(t=0){return new H(t)}static get ZERO(){return new H}static get MAX(){return new H([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127])}static get MIN(){return new H([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128])}}class K extends S{constructor(t=0){super(),b.call(this,new ArrayBuffer(32)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}static from(t=0){return new K(t)}static get ZERO(){return new K}static get MAX(){return new K([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255])}}class Q extends S{constructor(t=0){super(),b.call(this,new ArrayBuffer(32)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}static from(t=0){return new Q(t)}static get ZERO(){return new Q}static get MAX(){return new Q([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127])}static get MIN(){return new Q([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128])}}class tt extends S{constructor(t=0){super(),b.call(this,new ArrayBuffer(64)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}static from(t=0){return new tt(t)}static get ZERO(){return new tt}static get MAX(){return new tt([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255])}}class rt extends S{constructor(t=0){super(),b.call(this,new ArrayBuffer(64)),this._ta=new Uint32Array(this._ab),this.__set_value(t)}get isSignedInt(){return!0}static from(t=0){return new rt(t)}static get ZERO(){return new rt}static get MAX(){return new rt([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,127])}static get MIN(){return new rt([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128])}}const et=new Uint8Array([0]).buffer;function nt(t,r){at("$",it("$",t,r),t,r)}function it(n,i,a){if(void 0===i)return;if(null===i)return a(Uint8Array.from([e.NULL]).buffer),r.NULL;const s=typeof i;return"boolean"===s?(a(Uint8Array.from([i?e.TRUE:e.FALSE]).buffer),i?r.TRUE:r.FALSE):"number"===s?(a(Uint8Array.from([e.FLOAT64]).buffer),r.FLOAT64):"string"===s?(a(Uint8Array.from([e.STRING]).buffer),r.STRING):Array.isArray(i)?(a(Uint8Array.from([e.ARRAY]).buffer),r.ARRAY):i instanceof $?(a(Uint8Array.from([e.INT8]).buffer),r.INT8):i instanceof P?(a(Uint8Array.from([e.UINT8]).buffer),r.UINT8):i instanceof X?(a(Uint8Array.from([e.INT16]).buffer),r.INT16):i instanceof Z?(a(Uint8Array.from([e.UINT16]).buffer),r.UINT16):i instanceof z?(a(Uint8Array.from([e.INT32]).buffer),r.INT32):i instanceof x?(a(Uint8Array.from([e.UINT32]).buffer),r.UINT32):i instanceof W?(a(Uint8Array.from([e.INT64]).buffer),r.INT64):i instanceof J?(a(Uint8Array.from([e.UINT64]).buffer),r.UINT64):i instanceof H?(a(Uint8Array.from([e.INT128]).buffer),r.INT128):i instanceof q?(a(Uint8Array.from([e.UINT128]).buffer),r.UINT128):i instanceof Q?(a(Uint8Array.from([e.INT256]).buffer),r.INT256):i instanceof K?(a(Uint8Array.from([e.UINT256]).buffer),r.UINT256):i instanceof rt?(a(Uint8Array.from([e.INT512]).buffer),r.INT512):i instanceof tt?(a(Uint8Array.from([e.UINT512]).buffer),r.UINT512):i instanceof C?(a(Uint8Array.from([e.FLOAT32]).buffer),r.FLOAT32):i instanceof Date?(a(Uint8Array.from([e.DATE]).buffer),r.DATE):i instanceof RegExp?(a(Uint8Array.from([e.REGEX]).buffer),r.REGEX):i instanceof Map?(a(Uint8Array.from([e.MAP]).buffer),r.MAP):i instanceof Set?(a(Uint8Array.from([e.SET]).buffer),r.SET):i instanceof ArrayBuffer?(a(Uint8Array.from([e.ARRAY_BUFFER]).buffer),r.ARRAY_BUFFER):i instanceof DataView?(a(Uint8Array.from([e.DATA_VIEW]).buffer),r.DATA_VIEW):t&&i instanceof Buffer?(a(Uint8Array.from([e.SPECIAL_BUFFER]).buffer),r.SPECIAL_BUFFER):i instanceof Uint8Array?(a(Uint8Array.from([e.UINT8_ARRAY]).buffer),r.UINT8_ARRAY):i instanceof Int8Array?(a(Uint8Array.from([e.INT8_ARRAY]).buffer),r.INT8_ARRAY):i instanceof Uint16Array?(a(Uint8Array.from([e.UINT16_ARRAY]).buffer),r.UINT16_ARRAY):i instanceof Int16Array?(a(Uint8Array.from([e.INT16_ARRAY]).buffer),r.INT16_ARRAY):i instanceof Uint32Array?(a(Uint8Array.from([e.UINT32_ARRAY]).buffer),r.UINT32_ARRAY):i instanceof Int32Array?(a(Uint8Array.from([e.INT32_ARRAY]).buffer),r.INT32_ARRAY):i instanceof Float32Array?(a(Uint8Array.from([e.FLOAT32_ARRAY]).buffer),r.FLOAT32_ARRAY):i instanceof Float64Array?(a(Uint8Array.from([e.FLOAT64_ARRAY]).buffer),r.FLOAT64_ARRAY):Object(i)===i||"object"===s?"function"==typeof i.toBytes?(a(Uint8Array.from([e.UINT8_ARRAY]).buffer),r.BINARIZABLE):(a(Uint8Array.from([e.OBJECT]).buffer),r.OBJECT):(console.error(`Given path ${n} cannot be serialized as beson! Skipping...`),void console.error(i))}function at(t,e,n,i){if(void 0!==e&&e!==r.NULL&&e!==r.FALSE&&e!==r.TRUE)if(L.isBinaryData(n))i(n._ab);else if(e!==r.FLOAT64){if(e===r.STRING){const t=l(n);return i(new Uint32Array([t.byteLength]).buffer),void i(t)}if(e!==r.DATE){if(e===r.SPECIAL_BUFFER){const t=new Uint8Array(n.length);t.set(n);return i(new Uint32Array([t.length]).buffer),void i(t.buffer)}if(e===r.BINARIZABLE){const t=n.toBytes();if(!(t instanceof Uint8Array))throw new TypeError("Beson binary interface `toBytes` must return Uint8Array instance!");return i(new Uint32Array([t.length]).buffer),void i(t.buffer)}if(n instanceof ArrayBuffer){return i(new Uint32Array([n.byteLength]).buffer),void i(n)}if(ArrayBuffer.isView(n)){const t=n.buffer;return i(new Uint32Array([t.byteLength]).buffer),void i(t)}if(e===r.REGEX){const t=l(n.source);if(t.byteLength>65535)throw new RangeError("Beson can only accept regex with source string not longer than 65535 bytes!");const r=l(n.flags);if(r.byteLength>255)throw new RangeError("Beson can only accept regex with flag string not longer than 255 bytes!");return i(Uint16Array.from([t.byteLength]).buffer),i(t),i(Uint8Array.from([r.byteLength]).buffer),void i(r)}return e===r.ARRAY||e===r.SET?function(t,r,e){for(let n of r){void 0===n&&(n=null);at(t,it(t,n,e),n,e)}e(et)}(t,n,i):e===r.OBJECT?function(t,r,e){for(let n in r){const i=r[n];if(void 0===i)continue;const a=it(t=`\`${t}\`.\`${n}\``,i,e);st(`${n}`,e),at(t,a,i,e)}e(et)}(t,n,i):e===r.MAP?function(t,r,e){for(let[n,i]of r){if(void 0===i)continue;Object(n)===n&&console.error("You're serializing a Map that contains object key! Some object references will not be kept!");at(t=`\`${t}\`.\`${n}\``,it(t,n,e),n,e);at(t,it(t,i,e),i,e)}e(et)}(t,n,i):void 0}i(new Float64Array([n.getTime()]).buffer)}else{i(new Float64Array([n]).buffer)}}function st(t,r){const e=l(t);if(e.byteLength>65535)throw new RangeError("Given key cannot be larger than 65565 bytes!");r(Uint16Array.from([e.byteLength]).buffer),r(e)}const ut=new WeakMap;class ot{constructor(){const t=[];ut.set(this,{parts:t,data_cb:r=>{t.push(r)}})}write(t){return nt(t,ut.get(this).data_cb),this}get size(){const{parts:t}=ut.get(this);let r=0;for(const e of t)r+=e.byteLength;return r}get buffer(){return f(ut.get(this).parts)}static init(){return new ot}}function ft(r,e=0){if(t&&r instanceof Buffer){let t=Buffer.alloc(r.length);r.copy(t,0),r=t.buffer}return function(t,r){const e=lt(t,r);if(!e)return e;return ct(e.value,t,e.anchor)}(r,e)}function lt(t,n){if(t.length<n+1)return!1;const i=t[n];let a=null;for(const t in e){i===e[t]&&(a=r[t])}return a?{anchor:n+1,value:a}:void 0}function ct(e,n,i){if(e===r.NULL)return{anchor:i,value:null};if(e===r.TRUE)return{anchor:i,value:!0};if(e===r.FALSE)return{anchor:i,value:!1};if(e===r.INT8)return function(t,r){const e=1;if(t.length<r+e)return!1;const n=$.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.INT16)return function(t,r){const e=2;if(t.length<r+e)return!1;const n=X.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.INT32)return function(t,r){const e=4;if(t.length<r+e)return!1;const n=z.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.INT64)return function(t,r){const e=8;if(t.length<r+e)return!1;const n=W.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.INT128)return function(t,r){const e=16;if(t.length<r+e)return!1;const n=H.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.INT256)return function(t,r){const e=32;if(t.length<r+e)return!1;const n=Q.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.INT512)return function(t,r){const e=64;if(t.length<r+e)return!1;const n=rt.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.UINT8)return function(t,r){const e=1;if(t.length<r+e)return!1;const n=P.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.UINT16)return function(t,r){const e=2;if(t.length<r+e)return!1;const n=Z.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.UINT32)return function(t,r){const e=4;if(t.length<r+e)return!1;const n=x.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.UINT64)return function(t,r){const e=8;if(t.length<r+e)return!1;const n=J.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.UINT128)return function(t,r){const e=16;if(t.length<r+e)return!1;const n=q.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.UINT256)return function(t,r){const e=32;if(t.length<r+e)return!1;const n=K.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.UINT512)return function(t,r){const e=64;if(t.length<r+e)return!1;const n=tt.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.FLOAT32)return function(t,r){const e=4;if(t.length<r+e)return!1;const n=C.ZERO;return A(n._ba,t,e,r),{anchor:r+e,value:n}}(n,i);if(e===r.FLOAT64)return function(t,r){const e=8;if(t.length<r+e)return!1;const n=new Float64Array(t.slice(r,r+e).buffer);return{anchor:r+e,value:n[0]}}(n,i);if(e===r.STRING)return function(t,r){let e=4;if(t.length<r+e)return!1;const n=new Uint32Array(t.slice(r,r+e).buffer);if(r+=e,e=n[0],t.length<r+e)return!1;const i=new Uint8Array(t.slice(r,r+e).buffer);return{anchor:r+=e,value:c(i.buffer)}}(n,i);if(e===r.DATE)return function(t,r){const e=8;if(t.length<r+e)return!1;const n=new Float64Array(t.slice(r,r+e).buffer);return{anchor:r+e,value:new Date(n[0])}}(n,i);if(e===r.ARRAY_BUFFER)return At(n,i);if(e===r.DATA_VIEW){const t=At(n,i);return t?(t.value=new DataView(t.value),t):t}if(e===r.UINT8_ARRAY){const t=At(n,i);return t?(t.value=new Uint8Array(t.value),t):t}if(e===r.INT8_ARRAY){const t=At(n,i);return t?(t.value=new Int8Array(t.value),t):t}if(e===r.UINT16_ARRAY){const t=At(n,i);return t?(t.value=new Uint16Array(t.value),t):t}if(e===r.INT16_ARRAY){const t=At(n,i);return t?(t.value=new Int16Array(t.value),t):t}if(e===r.UINT32_ARRAY){const t=At(n,i);return t?(t.value=new Uint32Array(t.value),t):t}if(e===r.INT32_ARRAY){const t=At(n,i);return t?(t.value=new Int32Array(t.value),t):t}if(e===r.FLOAT32_ARRAY){const t=At(n,i);return t?(t.value=new Float32Array(t.value),t):t}if(e===r.FLOAT64_ARRAY){const t=At(n,i);return t?(t.value=new Float64Array(t.value),t):t}if(e===r.SPECIAL_BUFFER){const r=At(n,i);return r?(r.value=t?Buffer.from(r.value):new Uint8Array(r.value),r):r}return e===r.ARRAY?function(t,e){const n=[];for(;e<t.byteLength;){let i=lt(t,e);if(!i)return i;e=i.anchor;const a=i.value;if(a===r.END)break;if(i=ct(a,t,e),!i)return i;e=i.anchor,n.push(i.value)}return{anchor:e,value:n}}(n,i):e===r.OBJECT?function(t,e){const n={};for(;e<t.byteLength;){let i=lt(t,e);if(!i)return i;e=i.anchor;const a=i.value;if(a===r.END)break;if(i=ht(t,e),!i)return i;e=i.anchor;const s=i.value;if(i=ct(a,t,e),!i)return i;e=i.anchor,n[s]=i.value}return{anchor:e,value:n}}(n,i):e===r.SET?function(t,e){const n=new Set;for(;e<t.byteLength;){let i=lt(t,e);if(!i)return i;e=i.anchor;const a=i.value;if(a===r.END)break;if(i=ct(a,t,e),!i)return i;e=i.anchor,n.add(i.value)}return{anchor:e,value:n}}(n,i):e===r.MAP?function(t,e){const n=new Map;for(;e<t.byteLength;){let i=lt(t,e);if(!i)return i;e=i.anchor;const a=i.value;if(a===r.END)break;if(i=ct(a,t,e),!i)return i;e=i.anchor;const s=i.value;if(i=lt(t,e),!i)return i;e=i.anchor;const u=i.value;if(u===r.END)break;if(i=ct(u,t,e),!i)return i;e=i.anchor,n.set(s,i.value)}return{anchor:e,value:n}}(n,i):e===r.REGEX?function(t,r){let e=2;if(t.length<r+e)return!1;const n=new Uint16Array(t.slice(r,r+e).buffer);if(r+=e,e=n[0],t.length<r+e)return!1;const i=t.slice(r,r+e).buffer;if(r+=e,e=1,t.length<r+e)return!1;const a=t[r];if(r+=e,e=a,t.length<r+e)return!1;const s=t.slice(r,r+e).buffer;return{anchor:r+=e,value:new RegExp(c(i),c(s))}}(n,i):void 0}function ht(t,r){let e=2;if(t.length<r+e)return!1;const n=new Uint16Array(t.slice(r,r+e).buffer);if(r+=e,e=n[0],t.length<r+e)return!1;const i=new Uint8Array(t.slice(r,r+e).buffer);return{anchor:r+=e,value:c(i.buffer)}}function At(t,r){let e=4;if(t.length<r+e)return!1;const n=new Uint32Array(t.slice(r,r+e).buffer);if(r+=e,e=n[0],t.length<r+e)return!1;const i=t.slice(r,r+e).buffer;return{anchor:r+=e,value:i}}const bt=new Uint8Array(new ArrayBuffer(0));class yt{constructor(){ut.set(this,{buffer:bt}),this.throw_if_error=!1}read(){const t=ut.get(this),r=ft(t.buffer);if(void 0!==r){if(!1!==r){const{anchor:e,value:n}=r;return t.buffer=t.buffer.slice(e),n}}else if(this.throw_if_error)throw new TypeError("Data stored in Deserializer is not encoded in valid beson format")}append(t){if(ArrayBuffer.isView(t)&&(t=t.buffer),!(t instanceof ArrayBuffer))throw new TypeError("Given buffer is not an ArrayBuffer!");const r=ut.get(this);return r.buffer=new Uint8Array(f(r.buffer.buffer,t)),this}get size(){return ut.get(this).buffer.length}get buffer(){return ut.get(this).buffer.slice(0).buffer}static init(t=null){const r=new yt;return null===t&&(t=bt),r.append(t),r}}let wt;"undefined"!=typeof module&&module.exports?wt=module.exports:"undefined"!=typeof window&&(wt=window.beson=window.Beson=window.Beson||{});const _t={};Object.defineProperties(_t,{DeserializeBuffer:{value:ft,enumerable:!0},Deserializer:{value:yt,enumerable:!0},Serializer:{value:ot,enumerable:!0},UTF8Encode:{value:l,enumerable:!0},UTF8Decode:{value:c,enumerable:!0}}),Object.defineProperties(wt,{BinaryData:{value:L,enumerable:!0},BinaryInt:{value:S,enumerable:!0},Int8:{value:$,enumerable:!0},Int16:{value:X,enumerable:!0},Int32:{value:z,enumerable:!0},Int64:{value:W,enumerable:!0},Int128:{value:H,enumerable:!0},Int256:{value:Q,enumerable:!0},Int512:{value:rt,enumerable:!0},IntVar:{value:k,enumerable:!0},UInt8:{value:P,enumerable:!0},UInt16:{value:Z,enumerable:!0},UInt32:{value:x,enumerable:!0},UInt64:{value:J,enumerable:!0},UInt128:{value:q,enumerable:!0},UInt256:{value:K,enumerable:!0},UInt512:{value:tt,enumerable:!0},UIntVar:{value:j,enumerable:!0},Float32:{value:C,enumerable:!0},Deserialize:{value:function(t,r=!1){let e;if(t instanceof ArrayBuffer)e=new Uint8Array(t);else{if(!(t instanceof Uint8Array))throw new TypeError("Given input must be an ArrayBuffer or an Uint8Array");e=t}const n=ft(e,0);if(n)return n.value;if(r)throw new TypeError("Input data is not encoded in beson format!")},enumerable:!0},Serialize:{value:function(t){const r=[];return nt(t,(t=>{r.push(t)})),new Uint8Array(f(r))},enumerable:!0},Misc:{value:_t,enumerable:!0}})})();
